# 정보처리기사

# 소프트웨어 설계

### 소프트웨어 생명주기(소프트웨어 수명주기)

- {소프트웨어 개발 단계, 각 단계별 주요 활동, 활동 결과에 대한 산출물}로 표현한다.
- 생명 주기 표현 형태를 `생명주기모형`이라고한다. (=프로세스모형,소프트웨어공학 패러다임)

### 소프트웨어공학

- 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문.
- 여러가지 방법론,도구,관리 기법 등으로 `소프트웨어 품질과 생산성 향상을 목적`으로 한다.
- 소프트웨어 공학의 기본 원칙
    - **현대적** 프로그래밍 **기술**을 계속 **적용**해야한다
    - 개발된 소프트웨어의 품질이 유지되도록 **지속적으로 검증**해야한다.
    - 소프트웨어 개발 관련 사항 및 결과에 대한 **명확한 기록 유지**

### 폭포수 모형(Waterfall Model)

<aside>
💡 타당성 검토 → 계획 → 요구분석 → 설계 → 구현 → 시험 → 유지보수

</aside>

- 폭포수에서 떨어진 모형은 다시 거슬러 올라갈 수 없듯이, **소프트웨어 개발도 이전 단계로 돌아갈 수 없다.**
- 각 단계를 확실히 매듭짓고, 그 결과를 철저하게 검토 및 승인하여 다음 단계 진행
- 소프트웨어공학에서 가장 오래되고 가장 폭 넓게 사용된 전통적인 생명주기 모형. `고전적 생명주기 모형`이라고도 한다.
- 개발 과정 한 단계가 끝나야 다음 단계 진행 가능. `선형 순차적 모형`
- 이 모형을 적용한 경험과 성공 사례가 많다.
- 각 단계가 끝난 후 다음 단계를 위한 결과물이 명확하게 산출되어야한다.

### 나선형 모형(Spiral Model)

<aside>
💡 → 계획수립 → 위험 분석 → 개발 및 검증 → 고객 평가 →

</aside>

- 보헴의 제안
- 폭포수 모형,프로토타입 모형 의 장점 + 위험 분석 기능
- 나선을 따라 돌듯이 여러번의 개발 과정을 거쳐 점진적으로 완벽한 소프트웨어 개발. `점진적 모형`이라고도 한다.
- 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목표로 한다.
- 점진적으로 개발 과정 반복, 누락되거나 추가 요구사항 첨가 가능, 정밀하고 유지보수가 필요 없음

### 애자일 모형(Agile Model)

- 민첩한, 기민한, **고객의 요구사항 변화에 유연하게 대응** 할 수 있도록 일정 주기 반복하여 개발 진행
- 어느 특정 개발 방법론이라기보다, 고객과의 소통에 초점을 맞춘 방법론을 통칭한다.
- 기업 활동 전반에 걸쳐 사용된다.
- 애자일을 기반으로 하는 개발 모형에는 ~~스크럼(Scrum), XP(eXtreme Programming), 칸반 (Kanban), Lean, 크리스탈(Crystal), ASD(Adaptive Software Development), 기능 중심 개발(FDD; Feature Driven Development), DSDM(Dynamic System Development Method), DAD(Disciplined Agile Delivery) 등이 있다.~~

### 애자일 개발 핵심가치 4가지

1. 프로세스와 도구 보다는 개인과 상호작용에 더 가치를 둔다.
2. 방대한 문서보다 실행되는 소프트웨어에 더 가치를 둔다.
3. 계약 협상 보다는 고객과 협업에 더 가치를 둔다.
4. 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다.

### 스크럼(Scrum)

- 럭비처럼? 팀이 중심이 되어 개발의 효율성을 높인다.
- 스스로 팀을 구성(self-organizing), 스스로 해결(self-functional)
- 스크럼 팀은 제품 책임자,스크럼 마스터,개발팀으로 구성
    - 제품 책임자(PO; Project Owner)
        - 개발 될 제품에대한 이해도가 가장 높고, 요구사항을 책임지고 의사 결정할 사람으로 선정. 주로 클라이언트나 사용자.
        - 구성원의 의견을 종합하여 제품에 대한 요구사항 작성
        - 제품에 대한 테스트 수행하면서 요구사항 우선순위 갱신
    - 스크럼 마스터(SM; Srum Master)
        - 스크럼 팀이 스크럼을 잘 수행할 수 있도록 객관적인 시각에서 조언해주는 역할.
        - 일일 스크럼 회의를 주관하여 진행상황 점검. 개발 과정 중 발생된 장애 요소를 공론화 하여 처리
    - 개발팀(DT; Development Team)
        - PO,SM 제외한 모든 팀원. 개발자 이외에도 디자이너, 테스터 등 포함

### 스크럼 개발 프로세스

- 제품 백로그 : 제품 개발에 필요한 모든 요구사항을 우선순위에 따라 나열한 목록
- 스프린트 계획 회의 : 제품 백로그 중 이번 스프린트에 수행할 단기 일정 수립
- 스프린트 : 실제 개발 진행. 스프린트 백로그에 작성된 태스크 대상으로 velocity 추정 후 개발 담당자에게 할당
- 일일 스크럼 회의 : 모든 팀원이 매일 약속된 시간에 15분 정도 짧은 시간동안 진행상황 점검. 남은 작업시간은 소멸 차트에 표시
- 스프린트 검토 회의 : 부분(또는 전체) 완성 제품이 요구사항에 잘 부합하는지 사용자가 포함된 참석자 앞에서 테스팅 수행
- 스프린트 회고 : 스프린트 주기를 되돌아 보며 정해놓은 규칙 준수여부와 개선 방안에 대해 확인하고 기록.

### XP(eXtreame Programming)

- 수시로 발생하는 고객의 요구사항에 유연하게 대응하기위해 고객 참여와 개발 과정의 반복을 극대화 하여 개발 생산성 향상
- 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여로 **제품을 빠르게 개발 하는 것을 목적**으로 함.
- 릴리즈 기간을 짧게 반복하며 고객 요구사항 반영 가시성 높임
- XP 핵심 가치 5가지
    - **의사소통**(Communication), **단순성**(Simplicity), **용기**(Courage), **존중**(Respect), **피드백**(Feedback)
        - 고객 배제 아님

### XP의 주요 실천 방법

- **Pair Programming** : 다른 사람과 함께 개발. 개발에 대한 책임을 공동으로 나눔
- **Collective Ownership** : 개발 코드에 대한 권한과 책임을 공동으로 소유
- **Test-Driven Development** : 실제 코드 작성하기 전 테스트케이스 먼저 작성하여 자신이 무엇을 개발해야할지 정확히 파악. 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구 (Junit5) 를 사용
- **Whole Team** : 개발에 참여하는 모든 구성원은 각자 자신의 역할이 있고 역할에 책임을 가져야함.
- **Continuous Integration** : 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리 될 때마다 지속적으로 통합됨. 모듈단위?
- **Refactoring** : 프로그램 기능 변경 없이, 단순화,유연성 강화등을 통해 시스템 재구성
- **Small Releases** : 릴리즈 기간을 짧게 반복하여 고객의 요구 변화에 신속히 대응

### 현행 시스템 파악

- 1단계
    - 시스템 구성 파악 : 조직의 주요 업무를 담당하는 기간업무와 이를 지원하는 지원 업무로 구분해 기술함
    - 시스템 기능 파악 : 현재 제공하는 기능들을 주요 기능과 하부 기능, 세부 기능으로 구분하여 게층형으로 표시함
    - 시스템 인터페이스 파악 : 단위 업무 시스템 간에 주고받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등을 명시함
- 2단계
    - 아키텍처 구성 파악 : 최상위 수준에서 계층별로 표현한 아키텍쳐 구성도를 작성함
    - 소프트웨어 구성 파악 : 소프트웨어들의 제품명, 용도, 라이선스 적용방식, 라이선스 수 등을 명시함
- 3단계
    - 하드웨어 구성 파악 : 단위 업무 시스템들이 운용되는 서버의 주요 사양과 수량, 그리고 서버의 이중화 적용 여부를 명시함
    - 네트워크 구성 파악 : 서버의 위치, 서버간의 네트워크 연결 방식을 네트워크 구성도로 작성함

### 운영체제

컴퓨터 사용자와 컴퓨터 하드웨어간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공한다.

- 운영체제 관련 요구사항 식별 시 고려사항
    - 가용성
    - 성능
    - 기술 지원
    - 주변 기기
    - 구축 비용

### 데이터베이스 관리 시스템(DBMS)

사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해주고 데이터베이스를 관리해주는 소프트웨어이다.

DBMS는 기존 파일시스템이 갖는 데이터 종속성과 중복성 문제를 해결하기 위해 제안된 시스템으로 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리해준다.

DBMS는 데이터베이스 구성,접근 방법,유지관리(DDL,DCL,DML)에 대한 모든 책임을 진다.

DBMS의 종류에는 오라클,MYSQL,MongoDB 등이 있다.

- DBMS 관련 요구사항 식별 시 고려사항
    - 가용성
    - 성능
    - 기술 지원
    - ~~주변 기기~~ 상호 호환성
    - 구축 비용

### 웹 애플리케이션 서버(WAS)

웹 애플리케이션 서버는 동적인 컨텐츠를 처리하기 위해 사용되는 미들웨어이다.

- 데이터 접근,세션관리,트랜잭션 관리 등을 위한 라이브러리를 제공한다.
- 데이터베이스 서버와 연동하여 사용
- Tomcat

### 요구사항 정의

요구사항은 소프트웨어가 어떤 문제를 **해결하기 위해 제공하는 서비스**에 대한 설명과 **정상적으로 운영되는데 필요한 제약조건** 등을 나타낸다.

### 요구사항 유형

- 기능 요구사항
    - 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항
    - 시스템 입.출력 조건, 시스템이 어떤 데이터를 저장하거나 연산해야하는지
    - 시스템이 반드시 수행해야하는 기능
    - 사용자가 시스템을 통해 제공받기를 원하는 기능
- 비기능 요구사항
    - 시스템 장비 구성 요구사항
    - 성능 요구사항
    - 인터페이스 요구사항
    - 데이터 요구사항
    - 테스트 요구사항
    - 보안 요구사항
    - 품질 요구사항
    - 제약 사항
    - 프로젝트 관리 요구사항
    - 프로젝트 지원 요구사항

### 요구사항 개발 프로세스

요구사항 개발 프로세스는 **개발 대상에 대한 요구사항**을 체계적으로 **도출**하고 **분석한 후** 분석 결과를 **명세서에 정리**한 다음 마지막으로 이를 **확인 및 검증**하는 일련의 구조화 된 활동이다.

도출-분석-명세-확인

- 요구사항 도출
    
    시스템,사용자,개발자 등 서로 의견을 교환하여 요구사항이 어디에 있는지, 어떻게 수집할 것인지 식별하고 이해하는 과정
    
- 요구사항 분석
    
    개발 대상에 대한 사용자 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정
    
    - 요구사항 분석에는 자료 흐름도, 자료 사전 등이 사용됨
- 요구사항 명세
    
    분석된 요구사항을 바탕으로 모델을 작성하고 문서화 
    
    - 구체적인 명세를 위해 소단위 명세서가 사용됨
- 요구사항 확인
    - 개발자원을 요구사항에 할당하기전에 요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동

### 요구사항 명세 기법

정형적 명세 기법

수학적 원리 기반, 모델 기반

수학적 기호, 정형화된 표기법

요구사항을 정확하고 간결하게 표현할 수 있음

요구사항에 대한 결과가 작성자에 관계없이 일관성이 있으므로 완전성 검증이 가능

표기법이 어려워 사용자가 이해하기 어려움

VDM,Petri-net

비정형 명세 기법

상태/기능/객체 중심

일반 명사, 동사 등의 자연여 기반으로 서술 또는 다이어그램으로 작성

자연어 사용으로 요구사항에 대한 결과가 작성자에 따라 다를 수 있어 일관성이 떨어지고 해석이 달라질 수 있음

내용의 이해가 쉬워 의사소통이 용이함

FSM,Decision Table, ER 모델링

### 요구사항 분석의 개요

소프트웨어 개발의 실제적인 첫 단계로 개발 대상에 대한 사용자 요구사항을 이해하고 문서화 하는 활동

- 사용자 요구의 타당성을 조사하고 비용과 일정에 대한 제약을 설정한다
- 사용자의 요구를 정확하게 추출하여 목표를 정하고 어떤 방식으로 해결할 것인지 결정한다.
- 요구사항 분석을 통한 결과는 소프트웨어 설계 단계에 필요한 기본적인 자료가 되므로 사용자의 요구사항을 정확하고 일관성 있게 분석하여 문서화해야한다.
- 소프트웨어 분석가에 의해 요구사항 분석이 수행되며 이 작업단계를 요구사항 분석 단계라고 한다.
- 요구사항 분석을 위해 UML, 자료 흐름도, 자료 사전, 소단위 명세서 개체관계도 … 이게 무슨 ~~개소리~~ ..

### 자료흐름도

요구사항 분석에서 **자료의 흐름 및 변환 과정과 기능**을 도형 중심으로 기술하는 방법으로 자료 흐름 그래프, 버블 차트라고도 한다.

프로세스,자료흐름,자료 저장소, 단말 네 가지 기본 기호로 표시한다.

**프로세스 (Process)**

자료를 변환시키는 시스템의 한 부분, 처리,기능,변환 버블이라고도 함

**자료 흐름 (Data Flow)**

자료의 이동이나 연관관계를 나타냄

**자료 저장소 (Data Store)**

시스템에서의 자료 저장소를 나타냄, 도형안에 자료 저장소 이름을 기입함

**단말 (Teminator)**

시스템과 교신하는 외부 개체로 입력데이터가 만들어지고 출력 데이터를 받음

### 자료 사전 (Data dictonary)

자료 사전은 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것.이처럼 설명하는 데이터를 데이터의 데이터 또는 메타 데이터라고 한다.

### 요구사항 분석을 위한 CASE(자동화 도구)

소프트웨어 개발 과정에서 사용되는 요구분석,설계,구현,검사,디버깅 전체 또는 일부를 컴퓨터와 전용 소프트웨어를 이용해 자동화

공통 모듈을 사용해 재사용성 향상 가능

CASE가 모듈 관리를 자동으로 수행하므로 유지보수 간편

SADT

시스템정의,소프트웨어 요구사항 분석, 시스템/소프트웨어설계를 위해 널리 이용되어 온 구조적 분석 및 설계도구이다.

SREM = RSL/REVS

RSL : 요소,속성,관계, 구조들을 기술하는 요구사항 기술 언어

REVS : RSL로 기술된 요구사항들을 자동으로 분석하여 요구사항 분석 명서세를 출력

PSL/PSA

PSL과 PSA를 사용하는 자동화 도구

TAGS

시스템 공학 방법 응용에 대한 자동 접근 방법, 개발 주기 전 과정에 활용 가능한 통합 자동화 도구

### HIPO

시스템의 분석 및 설계, 문서화 할 때 사용되는 기법으로 시스템 실행과정인 입력,처리,출력의 기능을 나타냄

- 기본 시스템 모델은 입력-처리-출력으로 구성됨
- 하향식 소프트웨어 개발을 위한 문서화도구
- 체게적인 문서관리가 가능함
- 기호,도표 등을 사용해 보기 쉽고 이해하기 쉬움
- 기능과 자료의 의존 관계를 동시에 표현 가능
- 변경, 유지보수가 용이함
- 시스템의 기능을 여러 고유 모듈로 분할하여 인터페이스를 계층 구조로 표현한 것을 HIPO Chart라고함
    - 가시적 > 총체적 > 세부적
    - 가시적 도표
        - 시스템의 전체적인 기능,흐름을 보여주는 계층형 구조
    - 총체적 도표
        - 프로그램을 구성하는 기능을 기술, 입력-처리-출력의 전반적 정보를 제공
    - 세부적 도표
        - 총체적 도표에 표시된 기능을 구성하는 요소들을 상세히 기술

### UML

시스템 분석,설계,구현 등 시스템 개발 과정에서 고객 또는 개발자 간의 원활한 의사소통을 위해 표준화한 대표적인 객체지향 모델링 언어

- 객체 기술 국제 표준화 기구 OMG에서 표준으로 지정
- UML을 이용해 시스템 구조를 표현하는 6개 구조 다이어그램과 시스템 동작 표현하는 7개 행위 다이어그램 작성 가능
- 각 다이어그램은 사물-사물 의 관계를 용도에 맞게 표현
- 사물,관계,다이어그램 으로 구성됨

### 관계

**연관 관계**

2개 이상의 사물이 서로 관련되어 있음

**집합 관계**

하나의 사물이 다른 사물에 포함되어있음

**포함 관계**

집합 관계의 특수한 형태로 포함하는 사물의 변화가 포함 되는 사물에게 영향을 미침 (서로에게 영향을 끼침)

**일반화 관계**

하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지

**의존 관계**

서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간동안 연관을 유지

**실체화 관계**

사물이 할 수 있거나 해야하는 기능으로 서로를 그룹화 할 수 있는 관계

### 다이어그램

### 구조 다이어그램

**클래스 다이어그램**

클래스 사이의 관계를 표현함

시스템 구조를 파악하고 구조상의 문제점을 도출할 수 있음

클래스,제약조건,관계 등으로 구성된다

- 클래스
    
    일반적으로 3개의 구획으로 나누어 이름,속성(클래스의 상태나 정보) ,오퍼레이션(동작, 메소드라고도 함)을 표기함
    
- 제약조건
    
    속성에 입력될 값에 대한 제약조건이나, 함수 수행 전 후에 지정해야할 조건이 있다면 이를 적음
    
- 관계
    
    클래스와 클래스 사이 연관성
    
    클래스 다이어그램에 표현하는 관계에는 연관,집합,포함,일반화,의존(실체화 제외 전부)
    

**객체 다이어그램**

클래스에 속한 사물. 즉 인스턴스 를 특정 시점의 객체와 객체 사이의 관계로 표현함

럼바우 객체지향 분석 기법에서 활용됨

**컴포넌트 다이어그램**

실제 구현 모듈인 컴포넌트 간의 관계,인터페이스를 표현함

구현 단계에서 사용되는 다이어그램

**배치 다이어그램**

결과물,프로세스,컴포넌트 등 물리적 요소들의 위치를 표현함

노드와 의사소통 경로로 표현함

구현 단계에서 사용되는 다이어그램

**복합체 구조 다이어그램**

클래스나 컴포넌트가 복합 구조를 갖는 경우. 그 내부 구조를 표현함

**패키지 다이어그램**

유스케이스나 클래스 등 모델 요소들을 그룹화한 패키지들의 관계

### **행위 다이어그램**

**유스케이스 다이어그램**

사용자의 요구 분석, 기능 모델링 작업에 사용함

사용자와 사용사례로 구성됨. 사용 사례 간에는 여러 형태의 관계로 이루어짐

개발될 시스템과 관련된 외부 요소들. 사용자와 다른 외부 시스템이 개발될 시스템을 이용해 수행할 수 있는 기능을. 사용자 관점에서 표현

시스템,액터,유스케이스,관계 로 구성된다.

시스템 / 시스템 내부에서 수행되는 기능들을 외부 시스템과 구분하기 위해 시스템 내부를 사각형으로 묶어 시스템의 범위를 표현함

액터 / 시스템과 상호작용하는 모든 외부 요소로 사람이나 외부 시스템을 칭함.

주 액터 : 이 시스템으로 이득을 얻는 대상

부 액터 : 주 엑터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템,

유스케이스 / 사용자가 보는 관점에서 시스템이 엑터에게 제공하는 서비스 또는 기능

관계 / 액터-유스케이스, 유스케이스-유스케이스 사이에서 나타날 수 있고 연관,포함,확장,일반계 표현 가능

**순차 다이어그램**

상호작용하는 시스템이나 객체들이 주고받는 메시지

시간의 흐름에 따라 상호작용하는 과정을 액터,객체,메시지 등을 사용해 그림으로 표현

- 액터 / 시스템으로부터 서비스를 요청 하는 외부 요소, 사람이나 외부 시스템
- 객체 / 메시지를 주고받는 주체
- 생명선 / 객체가 메모리에 존재하는 기간, 객체 아래쪽에 점선을 그어 표현
- 실행 상자 / 객체가 메시지를 주고받으며 구동되고 있음
- 메시지 / 객체가 상호작요을 위해 주고받는 메시지

**커뮤니케이션 다이어그램**

순차 다이어그램처럼 같이 동작에 참여하는 객체들이 주고받는 메시지, 메시지 뿐 아니라 객체들간의 연관까지 표현

**상태 다이어그램**

하나의 객체가 자신이 속한 클래스 혹은 다른 객체와의 상호작용에 따라 **상태가 어떻게 변화하는지 표현**

럼바우 객체지향 분석 기법에서 동적 모델링에 활용됨

**활동 다이어그램**

시스템이 어떤 기능을 수행하는지, 객체 처리 로직이나 조건에 따른 처리의 흐름을 표현함

**상호작용 개요 다이어그램**

상호작용 다이어그램간의 제어 흐름을 표현

**타이밍 다이어그렘**

객체 상태 변화와 시간 제약을 명시적으로 표현

### 스테레오 타입

UML에서 표현하는 기능 외에 추가적인 기능을 표현하기 위해 사용

<<include>> 연결된 다른 UML 요소에 대해 포함 관계에 있는 경우

<<extend>> 연결된 다른 UML 요소에 대해 확장 관계에 있는 경우

<<interface>> 인터페이스를 정의하는 경우

<<exception>> 예외를 정의하는 경우

<<constuctor>> 생성자 역할을 수행하는 경우

### 사용자 인터페이스의 특징

1. 사용자의 만족도에 가장 큰 영향을 미치는 중요한 요소
2. 소프트웨어 영역중 변경이 가장 많이 발생
3. 사용자의 편리성과 가독성을 높이며 작업 시간을 단축시키고 업무에 대한 이해도를 높인다
4. 최소한의 노력으로 원라는 결과를 얻게한다
5. 사용자 중심으로 설계되어 사용자 중심의 상호작용이 되도록한다
6. 수행 결과의 오류를 줄인다
7. 사용자의 막연한 작업 기능에 대해 구체적인 방법을 제시한다
8. 정보 제공자와 공급자간의 매개 역할을 한다
9. 사용자 인터페이스를 설계하기 위해서는 소프트웨어 아키텍쳐를 반드시 숙지해야한다

### 사용자 인터페이스의 구분

- **CLI** 명령과 출력이 텍스트 환경의 인터페이스
- **GUI** 아이콘이나 메뉴를 마우스로. 그래픽 환경의 인터페이스
- **NUI** 사용자의 말이나 행동으로 조작하는 인터페이스
- **VUI** 사람의 음성으로 조작하는 인터페이스
- **OUI** 하드웨어 분야에서 사물인터넷,가상현실,증강현실과 함께 대두

### 사용자 인터페이스의 기본 원칙

- **직관성** 누구나 쉽게 이해하고 사용할 수 있어야함
- **유효성** 사용자의 목적을 정확하고 완벽히 달성
- **학습성** 누구가 쉽게 배우고 익힐 수 있어야함
- **유연성** 사용자의 요구사항을 최대한 수용하고 실수를 최소화

### 사용자 인터페이스의 설계 지침

- 사용자 중심
    
    사용자가 쉽게 이해하고 편리하게 사용할 수 있는 환경 제공, 실 사용자에 대한 이해가 바탕이 되어야함
    
- 사용성
    
    사용자가 소프트웨어를 얼마나 빠르고 쉽게 이해할 수 있는지, 얼마나 편하고 효율적으로 사용할 수 있는지. 를 말하는 것으로 가장 우선적으로 오려해야함
    
- 심미성
    
    디자인적으로 완성도 높게 글꼴이나 색상을 적용하고 그래픽 요소 배치하여 가독성 높이기
    
- 오류 발생 해결
    
    오류 발생하면 사용자가 쉽게 인지할 수 있도록 설계
    

### 사용자 인터페이스 개발 시스템의 기능

- 사용자의 입력을 검증할 수 있어야함
- 에러 처리와 그와 관련된 에러 메시지 표시 할 수 있어야함
- 도움과 프롬프트를 제공해야함

### UI 설계 도구

사용자의 요구사항에 맞게 UI의 화면 구조나 화면 배치 등을 설계할 때 사용하는 도구

**와이어프레임**

기획 단계 초기에 제작하는 것. 페이지에 대한 개략적인 레이아웃이나 UI 요소 등에 대한 뼈대 설계

개발자나 디자이너 등이 레이아웃을 협의하거나 진행상태 공유를 위해 와이어프레임을 사용함

**목업**

디자인,사용방법설명,평가 등을 위해 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형

시각적으로 구성 요소를 배치하는 것. 실제 구현되지는 않는다

**스토리보드**

와이어프레임 + 콘텐츠에 대한 설명, 페이지 간 이동 흐름 한 문서

디자이너와 개발자가 최종적으로 참고하는 작업 지침서. 정책,프로세스,콘텐츠 구성,와이어프레임,기능 정의 등 모든 정보가 다 들어있음

**프로토타입**

와이어프레임이나 스토리보드이 인터랙션을 적용하여 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형

사용성 테스트나 작업자 간 서비스 이해를 위해 작성하는 샘플

**유스케이스**

사용자 측명에서 요구사항으로 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술한다

사용자의 요구사항을 빠르게 파악해 프로젝트 초기에 기능적 요구를 결정하고 결과를 문서화

### 품질 요구사항

소프트웨어의 품질은 사용자의 요구사항을 충족시킴으로서 확립된다.

**기능성**

소프트웨어가 사용자의 요구사항을 정확하게 만족하는 **기능** 을 제공하는지

**신뢰성**

요구된 기능을 정확하고 일관되게 오류 없이 수행하는 정도

**사용성**

사용자와 컴퓨터 사이 행위에 대해 사용자가 정확하게 이해하고 사용하며. 다시 사용하고 싶은 정도

**효율성**

사용자가 요구하는 기능을 할당된 시간동안 한정된 자원으로 얼마나 빨리 처리할 수 있는지

**유지보수성**

환경의 변화 또는 새로운 요구사항이 발생했을 때 개선하거나 확장할 수 있는 정도

**이식성**

다른 환경에서도 쉽게 적용할 수 있는 정도

### UI 요소

체크박스,라디오버튼(여러항목 중 하나만 선택), 텍스트 박스, 콤보 상자,목록 상자

### 상위 설계와 하위 설계

상위 설계

아키텍쳐 설계,예비 설계

시스템의 전체적인 구조

구조,DB,인터페이스

하위 설계

모듈 설계, 상세 설계

시스템의 내부 구조 및 행위

컴포넌트, 자료 구조, 알고리즘

### 소프트웨어 아키텍쳐 설계의 기본 원리

**모듈화**

성능을 향상시키거나 시스템의 수정 및 재사용,유지관리 등이 용이하도록 시스템 기능들을 모듈 단위로 나누는 것

**추상화**

문제의 전체적이고 포괄적인 개념을 설계한 후 세분화하여 구체화시켜 나가는 것

과정추상화, 데이터 추상화, 제어 추상화

**단계적 분해**

하향식 설계 전략, 문제를 상위의 중요 개념으로부터 하위 개념으로 구체화시키는 분할 기법

**정보 은닉**

한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 함

### 소프트웨어 아키텍쳐의 품질 속성

**시스템 측면**

성능,보안,가용성,기능성,사용성,변경용이성,확장성

**비즈니스 측면**

시장 적시성,비용과 혜택,예상 시스템 수명

**아키텍쳐 측면**

개념적 무결성 정확성, 완결성, 구축 가능성

### 소프트웨어 아키텍쳐의 설계 과정

1. 설계 목표 설정
    
    개발 방향을 명확히 하기 위해 설계에 영향을 주는 BM, 우선순위 등의 요구사항을 분석하여 전체 시스템의 설계 목표를 설정
    
2. 시스템 타입 결정
    
    시스템과 서브 시스템 타입을 결정하고 설계 목표와 함께 고려하여 아키텍쳐 패턴 선택
    
3. 아키텍쳐 패턴 적용
    
    아키텍쳐 패턴 참조하여 시스템 표준 아키텍쳐 설계
    
4. 서브 시스템 구체화
    
    서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스 정의
    
5. 검토
    
    아키텍쳐가 설계 목표에 부합하는지, 요구사항이 잘 반영되었는지, 설계 기본 원리를 만족하는지 검토
    

### 협약에 의한 설계

컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것으로.  컴포넌트에 대한 정확한 인터페이스 명세

**선행 조건**

오퍼레이션(동작,함수)가 호출되기 전에 참이 되어야할 조건

**결과 조건**

오퍼레이션이 수행된 후 만족되어야할 조건

**불변 조건**

오퍼레이션이 수행되는 동안 항상 만족되어야할 조건 

### 파이프-필터 패턴

데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여. 파이프를 통해 데이터를 전송하는 패턴이다.

- 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장이 용이함
- 필터 컴포넌트를 재배치하여 다양한 파이프라인을 구축하는 것이 가능함
- 주로 데이터 변환,버퍼링,동기화 등에 주로 사용됨
- 대표적으로 Shell

### 모델-뷰-컨트롤러 패턴 (MVC)

**모델** / 서브시스템의 핵심 기능과 데이터를 보관함

**뷰** / 사용자에게 정보를 표시함

**컨트롤러** / 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령을 보냄

### 기타 패턴

마스터-슬레이브,브로커,피어-투-피어패턴,이벤트-버스 패턴 블랙보드 패턴, 인터프리터 패턴 .. 

### 객체(Object)

객체는 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 소프트웨어 모듈이다.

**데이터**

객체가 가지고 있는 정보로 속성,상태, 분류 등을 나타냄. 속성.상태.상수. 자료구조 라고도 함

**함수**

객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘

메소드,서비스,동작,연산이라고도 함

**객체의 특성**

객체는 독립적으로 식별가능한 이름을 가지고 있다.

객체가 가질 수 있는 조건을 state 라고 하는데 일반적으로 상태는 시간에 따라 변한다

객체와 객체는 상호 연관성에 대한 관계가 형성된다

객체가 반응할 수 있는 메시지의 집합을 행위라고 하며 객체는 행위의 특징을 ….. 

### 클래스

클래스는 공통된 속성과 연산행위를 갖는 객체의 집합으로 객체의 일반적인 타입을 의미한다.

클래스는 객체지향 프로그램에서 데이터를 추상화하는 단위이다.

클래스가 속한 각각의 객체를 인스턴스라고 하며 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화라고 한다.

### 캡슐화

데이터와 데이터를 처리하는 함수를 하나로 묶는 것을 의미한다.

캡슐화된 객체는 세부 내용이 은폐되어 외부에서 접근이 제한적이기 때문에 외부 모듈 변경으로 인한 파급 효과가 적다.

캡슐화 된 객체들을 재사용이 용이하다

객체들간 메시지를 주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고 객체간 결합도가 낮아진다.

### 상속

이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것이다.

상속을 이용하면 자신 클래스내에서 다시 정의하지 않고 즉시 자신의 속성으로 사용할 수 있다.

하위 클래스는 상위 클래스로부터 받은 속성과 연산 외에 새로운 속성과 연산을 첨가해 사용할 수 있다.

### 다형성

메시지에 의해 객체가 각 연산을 수행할 때 각 객체가 가지고 있는 고유한 방법(특성)으로 응답할 수 있는 능력을 의미한다.

객체들은 동일한 메소드 명으로 같은 의미의 응답을 한다.

오버로딩 기능의 경우 메소드 이름은 같지만 인자로 넘겨받는 자료형과 개수를 달리하여 여러 기능을 정의할 수 있다.

오버라이딩 기능의 경우 상위클래스에서 정의한 메소드와 이름은 같지만 메소드 안의 실행코드를 달리하여 자식 클래스에서 재정의해서 사용할 수 있다

### 연관성

is member of / 연관화 / 2**개** 이상의 객체가 상호 관련되어있음

is instance of / 분류화 / 동일한 **형**의 특성을 갖는 객체들을 모아 구성하는 것

is a part of / 집단화 / 관련 있는 객체들을 묶어 하나의 상위 객체를 구성

is a / 일반화 / 공통적인 성질들로 추상화한 **상위** 객체를 구성하는 것

is a / 특수,상세화 / 상위 객체를 구체화하여 **하위** 객체를 구성하는 것

### 객체지향 분석의 방법론

Rumbaugh 방법 `가장일반적` `객동기`

가장 일반적으로 사용되는 방법으로 분석활동을 객체모델,동적모델,기능 모델로 나누어 수행

럼바우의 분석 기법

모든 소프트웨어 구성 요소를 그래픽 표기법을 이용해 모델링하는 기법으로 객체 모델링이라고도 한다.

객체모델링-동적모델링-기능모델링

부치 방법 `미시적거시적`

미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법. 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의함

Jacobson 방법 `usecase`

Use Case를 강조하여 사용하는 분석 방법

Coad와 Yourdon 방법 `E-R다이어그램`

E-R 다이어그램을 사용해 객체 행위를 모델링하며 …

Wirfs-Brock 방법 분석설계구분없음

분석과 설계간의 구분이 없고 고객 명세서를 평가하여 설계 작업까지 연속적으로 수행

### 객체지향 설계 원칙

**단일 책임 원칙 SRP**

객체는 단 하나의 책임만 가져야 한다

**개방-폐쇄 원칙 OCP**

기존 코드는 변경하지 않고 기능을 추가할 수 있도록 설계해야한다

**리스코프 치환 원칙 LSP**

자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야한다

**인터페이스 분리 원칙 ISP**

자신이 사용하지 않는 인터페이스와 의존관계를 맺거나 영향을 받지 말아야한다

**의존 역전 원칙 DIP**

각 객체들간 의존 관계가 성립될 때 추상성이 높은 클래스와 관계를 맺어야한다

### 결합도

모듈간에 상호 의존하는 정보 또는 두 모듈 사이의 연관관계를 의미

**자료 결합도** `자료요소로만`

자료 요소로만 구성될 때 결합도

**스탬프 결합도** `레코드등`

배열이나 레코드 등의 자료구조가 전달될 때 결합도

**제어 결합도** `제어신호`

다른 모듈 내부의 논리적  흐름을 제어하기 위해 제어신호 사용

외부 결합도 `변수외부에서참조`

어떤 모듈에서 선언한 변수를 외부의 다른 모듈에서 참조할 때

공통 결합도 `공통데이터영역`

공유되는 공통 데이터 영역을 여러 모듈이 사용할 때

내용 결합도 `내부자료참조`

다른 모듈의 내부 기능 및 내부 자료를 직접 참조하거나 수정할 때

### 응집도

**기능적 응집도**

모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우

**순차적 응집도**

모듈 내 하나의 활동으로 나온 출력 데이터를 그 다음 활동의 입력 데이터로

**교환(통신)적 응집도**

동일한 입출력을 사용해 서로 다른 기능을 수행하는 구성 요소들이 모일 때

**절차적 응집도**

관련 기능을 가질 때 기능을 순차적으로 수행할 경우의 응집도

**시간적 응집도**

특정 시간에 처리되는 몇개의 기능을 모아 하나의 모듈로 작성할 경우

**논리적 응집도**

유사 성격을 갖거나 특정 형태로 분류되는 요소들로 하나의 모듈이 형성되는 경우

**우연적 응집도**

모듈 내부의 각 구성 요소들이 관련없는 요소로 구성된 경우

### 팬인/팬아웃(그림 참고)

팬인 / 어떤 모듈을 제어하는 모듈의 수

팬아웃 / 어떤 모듈에 의해 제어 되는 모듈의 수

### N-S 차트

N-S 차트는 논리의 기술에 중점을 둔 도형을 이용한 표현 방법으로 박스 다이어그램. Chapin Chart라고도 한다.

- 연속,선택 및 다중선택, 반복 등의 제어 논리 구조를 표현
- GOTO나 화살표를 사용하지 않음
- 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합
- 선택과 반복 구조를 시각적으로 표현
- 이해하기 쉽고, 코드 변환이 용이하다.
- 읽기는 쉽지만 작성하기 어려우며 임의로 제어를 전이하는 것이 불가능
- 총체적인 구조 표현과 인터페이스를 나타내기가 어렵다
- 단일 입구와 단일 출구로 표현

### 공통 모듈의 개요

자주 사용되는 계산식이나 매번 필요한 사용자 인증과 같은 기능이 공통 모듈로 구성될 수 있다.

모듈의 재사용성 확보와 중복 개발을 막기위해 설계 과정에서 공통 부분을 식별하고 명세 작성

공통 모듈을 구현할 때는 다른 개발자들이 해당 기능을 명확히 히해하도록 다음 명세 기법을 준수해야한다.

정확성 / 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성

명확성 / 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성

완전성 / 시스템 구현을 위해 필요한 모든 것을 기술

일관성 / 공통 기능들 간 상호 충돌이 발생하지 않도록 작성

추적성 / 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성함

### 공통 모듈 - 재사용

비용과 개발시간 절약을 위해 이미 개발된 기능들을 파악하고 재구성 하여 새로운 시스템 또는 기능개발에 사용하기 적합하도록 최적화 시키는 작업이다.

재사용을 위해서는 누구나 이해할 수 있고 사용 가능하도록 사용법을 공개해야한다.

재사용되는 대상은 외부 모듈과의 결합도는 낮고, 응집도는 높아야한다

재사용 규모에 따른 분류

- 함수와 객체 : 클래스나 메소드 단위의 소스코드를 재사용함
- 컴포넌트 : 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용함
- 애플리케이션 : 공통된 기능을 제공하는 애플리케이션을 공유함

### 효과적인 모듈 설계 방안

1. **결합도**는 줄이고 **응집도**는 높여서 모듈의 **독립성**과 **재사용성**을 높인다.
2. 모듈의 제어 영역 안에서 모듈의 영향 영역을 유지시킨다.
3. 복잡도와 중복성을 줄이고 일관성을 유지시킨다
4. 모듈의 기능은 예측이 가능해야하며 지나치게 제한적이어서는 안된다.
5. 유지보수가 용이해야한다
6. 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해한다
7. 효과적인 제어를 위해 모듈 간의 계층적 관계를 정의하는 자료가 제시되어야한다

### 코드의 개요

컴퓨터를 이용해 자료를 처리하는 과정에서 분류,조합 및 집계를 용이하게 하고 특정 자료 추출을 쉽게 하기 위해 사용하는 기호 .. 

식별기능,분류기능,배열기능,표준화기능,간소화기능

### 디자인 패턴의 개요

코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결방식 및 예제

디자인패턴은 문제 및 배경, 실제 적용된 사례, 재사용 가능한 샘플 코드 등으로 구성되어있다.

개발 과정중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적이다

GoF의 디자인 패턴은 유형에 따라 생성패턴 5개, 구조패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성된다

### 디자인 패턴 사용의 장단점

1. 범용적인 코딩 스타일로 구조 파악이 용이하다
2. 객체지향 설계 및 구현의 생산성을 높이는데 적합하다
3. 검증된 구조의 재사용으로 개발 시간과 비용이 절약된다
4. 초기 투자 비용이 부담될 수 있다
5. 개발자간 원활한 의사소통이 가능하다
6. 설계 변경 요청에 대한 유연한 대처가 가능하다
7. 객체지향을 기반으로 한 설계과 구현을 다루므로 다른 기반의 애플리케이션 개발에는 적합하지 않다

### 생성 패턴

객체의 생성과 관련된 패턴으로 총 5개의 패턴이 있다.

**추상팩토리** 

구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관,의존하는 객체들의 그룹으로 생성하여 추상적으로 표현

연관된 서브 클래스를 묶어 한번에 교체 가능

**빌더 (Builder)**

작게 분리된 인스턴스를 조합하여 객체를 생성

객체의 생성과 표현을 분리하고있어 동일한 객체 생성에도 다른 결과를 만들어낼 수 있음

**팩토리 메소드 (Factory Method)** `가상생성자` `서브클래스가 결정`

객체 생성을 서브 클래스에서 처리하도록 분리화하여 캡슐화한 패턴

상위클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당.

가상 생성자라고도함

**프로토타입**

원복 객체를 복제하는 방법으로 객체 생성

일반적인 방법으로 객체를 생성하며 비용이 큰 경우 주로 이용함

**싱글톤 (Singleton)**

하나의 객체를 생성하면 생성된 객체를 어디서든  참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없음

클래스 내에서 인스턴스가 하나뿐임을 보장하며 불필요한 메모리 낭비 최소화

### 구조 패턴

**어댑터 (Adaptor)** `인터페이스가 일치하지 않을 때`

호환성 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해줌

기존 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때

**브리지 (Bridge)** `기능과구현을별도클래스로`

구현부에서 추상층을 분리하여 서로 독립적으로 확장할 수 있도록 구성

기능과 구현을 두개의 별도 클래스로 구현

**컴포지트 (Composite)** `트리구조`

여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자할 때

객체들을 트리 구조롤 구성하여 복합 객체안에 복합 객체가 포함되는 구조로 표현 가능

**데코레이터 (Decorator)** `다른객체덧붙임`

객체 간의 결합을 통해 능동적으로 기능 확장가능한 패턴

임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체 덧붙임

**퍼싸드 (Facade)** `wrapper`

복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성. 서브 클래스들의 기능을 간편하게 사용할 수 있도록함

서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 필요

**플라이웨이트 (Flyweight)** `공유사용메모리절약`

인스턴스가 필요할 때마다 매번 생성하는 것이 아니고, 가능한 한 공유해서 사용하여 메모리 절약

다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용

**프록시 (Proxy)** `프록시객체`

접근이 어려운 객체와 여기 연결하려는 객체 사이에서 인터페이스 역할을 수행

네트워크 연결, 메모리 대용량 객체로의 접근 등에 주로 이용

### 행위 패턴

**책임 연쇄(Chain of Responsibility)**

요청을 처리할 수 있는 객체가 둘 이상 존재. 한 객체가 처리하지 못하면 다음 객체로 패스

요청 처리하는 각 객체들이 고리(Chain)으로 묶여있어 요청 해결될 때까지 chain으로 책임이 넘어감

**커맨드(Command)**

요청을 객체 형태로 캡슐화하여 재이용,취소 할 수있도록 요청에 필요한 정보를 저장.로그에 남김

**인터프리터(Interpreter)**

언어에 문법 표현을 정의함. SQL이나 통신 프로토콜 같은 것을 개발할 때 사용

**반복자(Iterator)**

접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록함. 내부 표현 방법의 노출 없이 순차적 접근 가능

**중재자(Medicator)**

객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의

객체 사이의 의존성을 줄여 결합도 감소

**메멘토(Memento)**

특정 시점에서 객체 내부 상태를 객체화하여 요청에 따라 해당 시점 상태로 돌릴 수 있는 기능 제공 ctrl + z

**옵서버(Observer)**

객체의 상태가 변화하면 객체에 상속되어있는 다른 객체들에 상태를 전달. 주로 분산된 시스템 간에 이벤트 생성, 발행 하고 수신자에게 전달

**상태(State)**

객체의 상태에 따라 동일한 동작을 다르게 처리

객체 상태를 캡슐화 하고 이를 참조

**전략(Strategy)**

동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환

클라이언트는 독립적으로 원하는알고리즘 선택하여 사용 가능,

**템플릿 메소드(Template Method)**

상위 클래스에서 골격을 정의하고 하위 클래스에서 세부 처리 구체화

유사 서비스 클래스를 묶어 공통된 내용을 상위 클래스에서 정의하여 유지보수 용이

**방문자(Vistor)**

각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도 클래스로 구성. 분리된 처리 기능은 각 클래스 방문하여 수행

### 요구사항 검증 방법

요구사항 검토

- 동료 검토
    - 명세서 내용을 직접 설명하고 이를 들으면 동료들이 결함을 발견하는 형태
- 워크스루
    - 사용 사례를 확장하여 명세
    - 회의전에 미리 배포하여 사전 검토한 후에 짧은 검토 회의를 통해 결함 발견하는 검토 방법
    - 설계 다이어그램,원시코드,테스트 케이스에 적용 가능
    - 복잡한 알고리즘,시리간 동작, 병행처리 등과 같이 기능이나 동작 이해할 때 유용
    - 인스펙션과 다른의미, 워크스루를 발전시킨 형태가 인스펙션임.
        - 인스펙션은 산출된 결과물의 품질을 평가하고 이를 개선시키기 위한 방법
- 인스펙션
    - 요구사항 명세서 작성자를 제외한 다른 사람이 결함을 발견하는 검토 방법

프로토타입

실제 개발될 소프트웨어에대한 견본품(프로토타입)을 만들어 최종 결과물을 예측함

테스트 설계

테스트 케이스를 생성하여 이후 요구사항이 현실적으로 테스트 가능한지 검토함

CASE 도구 활용

일관성 분석을 통해 요구사항 변경사항의 추적 및 분석, 관리하고 표준 준수 여부 확인

CASE

### 시스템 연계 기술

DB Link

DB에서 제공하는 DB Link 객체를 이용하는 방식

API/Open Api

송신 시스템의 DB에서 데이터를 읽어와 제공하는 Application Programming Interface Program

연계 솔루션

EAI 서버와 송수신 시스템에 설치되는 클라이언트를 이용하는 방식

Socket

서버는 통신을 위한 소켓을 생성하여 포트를 할당하고 클라이언트의 통신 요청시 클라이언트와 연결하여 통신하는 네트워크 기술

Web Service

WSDL, UDDI, SOAP 프로토콜을 이용해 연계하는 서비스

### 연계 메커니즘 구성요소

송신 시스템

연계 프로그램으로부터 생성된 데이터를 전송 형식에 맞게 변환하여 송신

수신 시스템

수신한 데이터를 처리할 수 있는 형식으로 변환 후 연계 프로그램에 반영

연계 서버

송,수신 시스템 사이에 위치해 데이터의 송,수신 현황을 모니터링함

### 미들웨어

운영체제와 응용 프로그램, 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어

**DB**

DB를 사용해 시스템을 구축하는 경우 2-Tier 아키텍쳐라고함

**RPC**

응용 프로그램의 프로시저를 사용해 원격 프로시저를 로컬 프로시저처럼 호출하는 방식

**MOM**

메시지 지향 미들웨어. 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 사용됨

**TP-Monitor** `트랜잭션`

항공기나 철도 예약 업무 같은. 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어. 사용자수가 증가해도 빠른 응답 속도를 유지해야하는 업무에 사용됨

**ORB**

객체 요청 브로커. 객체 지향 미들 웨어로, TP-Monitor의 장점인 트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있음?

**WAS**

웹 애플리케이션 서버. 동적인 컨텐츠 처리하기 위해 사용되는 미들 웨어. 클라이언트/서버보다 웹 환경 구축을 위한 미들웨어